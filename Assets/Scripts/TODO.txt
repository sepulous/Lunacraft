TODO:
    * Add structures

    * Sounds

    * Player model

    * Jetpack

    * Skybox

    * Day/night cycle

    * Multiplayer (eh, idk)

    * Mining/placing

    * Inventory

    * Crafting

    * Mobs





For a 3D array of d1 x d2 x d3

    3D -> 1D: (i, j, k) -> n = i*d2*d3 + j*d3 + k

    1D -> 3D: i = FLOOR(n / (d2 * d3))
              j = FLOOR((n % (d2*d3)) / d3)
              k = n % d3


    FUN FACT: If I keep the chunk dimensions as powers of two, these divisions are just bit shifts

    FUN FACT #2: A remainder from a division by a power of two can be computed as:
        r = n - q*2^k
          = n - (n >> k)*2^k
          = n - (n >> k) << k

    FUN FACT #3: floor(x) can be computed as:
        int floor(float x)
        {
            int sign = x >> 31;
            return (int)x - sign;
        }

    As long as d1, d2, and d3 are powers of two, there's no need for multiplication, division, or branching

    When I implement this, let's start with native Unity/C# functions, and then try these custom methods, and benchmark both







struct RenderCheckJob : IJob
{
    NativeArray<byte> chunk;
    NativeArray<byte> leftChunk;
    NativeArray<byte> rightChunk;
    NativeArray<byte> frontChunk;
    NativeArray<byte> backChunk;
    NativeArray<byte> output;
}

The neighboring chunk data already exists, just find the right chunks and pass them in
    - Already have GetNeighboringChunks()

RenderCheckJob renderCheckJob = new RenderCheckJob {
    chunk = chunk,
    leftChunk = leftChunk,
    ...
};

for (int i = 0; i < chunkData.blocks.Length; i++)
{
    byte blockID = chunkData.blocks[i];
    int localBlockX = FLOOR(i / (GameData.WORLD_HEIGHT_LIMIT * GameData.CHUNK_SIZE));
    int localBlockY = FLOOR((i % (GameData.WORLD_HEIGHT_LIMIT * GameData.CHUNK_SIZE)) / GameData.CHUNK_SIZE);
    int localBlockZ = i % GameData.CHUNK_SIZE;
    ...
    output[i] = blockIsTouchingAir ? 1 : -1;
}

LATER (LateUpdate?)

int positionIndex = 0;
for (int i = 0; i < output.Length; i++)
{
    byte blockID = output[i];
    if (blockID != -1)
    {
        float localPosX = positions[positionIndex];
        float localPosY = positions[positionIndex+1];
        float localPosZ = positions[positionIndex+2];
        RenderBlock();
    }
    positionIndex += 3;
}






TODO:
    [ ] Integrate options
            [ ] Sfx volume
            [ ] Music volume
            [X] Sensitivity
            [X] Render distance (dynamic)
            [ ] Show GUI
            [ ] Show fog
            [X] Debug info
    [ ] Add more plant variants
    [ ] Fix holes in crystal plant textures
    [ ] Add shadows to sides of water blocks
    [ ] Factor moon settings into generation
        - Take better control of the algorithm first. It's too finicky as it is.
    [ ] Make ice movement faster/slidier
    [ ] Multi-thread rendering
        - Or better yet: Make the current system as efficient as possible and see if multithreading is actually necessary.
                         As much as I want to multithread this, Unity makes it painful.

        Multithread gameplan:
            1. Make chunk management one-dimensional. No more 3D arrays. Let's see if this alone improves the performance enough to render multithreading unnecessary
            2. If it's still about as slow, at least it's in a better format for multithreading, so try that







Two things to try:
    1. Significantly lower global padding (to ~3). Add structure candidates randomly so they aren't always next to each other.
       Then have each structure loop through the candidates until one works.

        - # of candidates (on average) should be at least the max number of ores/structures that can spawn

        Pros:
            - Little modification to current system
            - I know in advance that the candidate blocks are valid (topsoil/sand)

        Cons:
            - Unknown overhead from random number generation
            - Unknown how many candidates a structure has to loop through
            - Many vectors have to be created and a list has to be managed

    
    2. Each structure stores the amount of space it takes up. It then generates random (x, z) coordinates that respect the amount of
       space it needs, and loops from y=64 up until air is hit. The block below may or may not be topsoil/sand, in which case the
       structure will be skipped.

        Pros:
            - No need to generate/store a bunch of structure candidates
            - Significantly fewer random number generations

        Cons:
            - This changes the system fundamentally. In the first method, we spawn exactly as many as we want, but now we have to
              concede if the top block happens to be invalid

            - This doesn't take advantage of the knowledge of the terrain blocks while the terrain is being generated. We're basically
              pretending to be blind.
                - What if the entire top of the chunk is water? Why should this run at all?






// 2D simplex noise
public static float noise(float xin, float zin)
{
    float n0, n1, n2; // Noise contributions from the three corners

    // Skew the input space to determine which simplex cell we're in
    final float F2 = 0.5*(Math.sqrt(3.0)-1.0);
    float s = (xin+zin)*F2; // Hairy factor for 2D
    int i = fastfloor(xin+s);
    int j = fastfloor(zin+s);
    final float G2 = (3.0-Math.sqrt(3.0))/6.0;
    float t = (i+j)*G2;
    float X0 = i-t; // Unskew the cell origin back to (x,y) space
    float Y0 = j-t;
    float x0 = xin-X0; // The x,y distances from the cell origin
    float y0 = zin-Y0;

    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
    else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    float x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    float y1 = y0 - j1 + G2;
    float x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
    float y2 = y0 - 1.0 + 2.0 * G2;

    // Work out the hashed gradient indices of the three simplex corners
    int ii = i & 255;
    int jj = j & 255;
    int gi0 = perm[ii+perm[jj]] % 12;
    int gi1 = perm[ii+i1+perm[jj+j1]] % 12;
    int gi2 = perm[ii+1+perm[jj+1]] % 12;

    // Calculate the contribution from the three corners
    float t0 = 0.5 - x0*x0-y0*y0;
    if (t0 < 0) {
        n0 = 0.0;
    }
    else {
        t0 *= t0;
        n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
    }

    // BRANCHLESS VERSION OF THE ABOVE CODE
    // uint t0_sign_bit = (uint)t0 >> 31; // 1 if t0 < 0, 0 if t0 >= 0
    // n0 = (1 - t0_sign_bit) * (t0 * t0) * (t0 * t0) * dot(grad3[gi0], x0, y0);

    float t1 = 0.5 - x1*x1-y1*y1;
    if (t1 < 0) {
        n1 = 0.0;
    }
    else {
        t1 *= t1;
        t1_new = t1 * t1
        n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
    }

    // BRANCHLESS VERSION OF THE ABOVE CODE
    // uint t1_sign_bit = (uint)t1 >> 31; // 1 if t1 < 0, 0 if t1 >= 0
    // n1 = (1 - t1_sign_bit) * (t1 * t1) * (t1 * t1) * dot(grad3[gi1], x1, y1);

    float t2 = 0.5 - x2*x2-y2*y2;
    if (t2 < 0) {
        n2 = 0.0;
    }
    else {
        t2 *= t2;
        n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
    }

    // BRANCHLESS VERSION OF THE ABOVE CODE
    // uint t2_sign_bit = (uint)t2 >> 31; // 1 if t2 < 0, 0 if t2 >= 0
    // n2 = (1 - t2_sign_bit) * (t2 * t2) * (t2 * t2) * dot(grad3[gi2], x2, y2);
    
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70.0 * (n0 + n1 + n2);
}
